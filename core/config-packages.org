* ELPA

  ELPA 是 Emacs Lisp Package Archive 的缩写。[[http://elpa.gnu.org/packages/][gnu]] 是 ELPA 的官方（内置）
源 ，但里面的包不多而且更新不及时。melpa 是一个流行的第三方源。

  package.el 实现了 Emacs 的包管理系统。从 ELPA 下载的包会安装到
package-user-dir 目录下，并组织在以 /name-version/ 风格命名的子目录里。
package-user-dir 目录下所有的内容被称为 Package Contents。

  下面是 package 中其中几个常用的函数。
  - package-initialize :: 更新本地 Package 安装列表，将各 Package 加到
       load-path，运行其 /name/-autoloads.el 文件
  - package-refresh-contents :: 从 ELPA 下载包的数据。注意，下载数据后
       才可以用 package-install 安装服务器上的包
  - package-list-packages（list-packages） :: 从 ELPA 下载包的描述（可
       以用 prefix 跳过），并列出包的列表
  - package-install :: 安装包

  下面是 Emacs 的启动过程：
  - 加载 init 文件和 abbrev 文件
  - 运行 package-initialize 加载安装的 Package
  - 运行 after-init-hook。

  所以，缺省不能在 init 文件的加载过程中使用 Package（如 use-package）。
为了解决这个问题，我们可以在 init 文件中显式地运行 package-initialize。

* 定义函数

#+BEGIN_SRC emacs-lisp
  (defun bw/install-package-on-demand-impl (package &optional min-version no-refresh)
    "按需安装 PACKAGE。
  MIN-VERSION：可选参数，指定 PACKAGE 最低版本。
  NO-REFRESH：如果是非 nil，则不从 ELPA 重新下载数据。"
    (if (package-installed-p package min-version)
        t
      (if (or (assoc package package-archive-contents) no-refresh)
          ;; PACKAGE 已经在 package-archive-contents 中，或者要求不刷新，
          ;; 则直接安装 PACKAGE
          (if (boundp 'package-selected-packages)
              ;; Record this as a package the user installed explicitly
              (package-install package nil)
            (package-install package))
        ;; 否则，刷新 package-archive-contents，然后递归调用自身函数，安
        ;; 装 PACKAGE
        (progn
          (package-refresh-contents)
          (bw/install-package-on-demand-impl package min-version t)))))


  (defun bw/install-package-on-demand (package &optional min-version no-refresh)
    "按需安装 PACKAGE。如果安装失败，打印一条错误信息。
  MIN-VERSION：可选参数，指定 PACKAGE 最低版本。
  NO-REFRESH：如果是非 nil，则不从 ELPA 重新下载数据。"
    (condition-case err
        (bw/install-package-on-demand-impl package min-version no-refresh)
      (error
       (message "Couldn't install optional package `%s': %S" package err)
       nil)))
 #+END_SRC

* 使用 use-package

  [[https://github.com/jwiegley/use-package][use-package]] 提供了一个灵活、强大的配置 Emacs 扩展包的宏，把扩展包的
安装、配置都封装在一段代码里。

  值得注意的是，use-package 不会自动调用 package-refresh-contents。如
果在 use-package 自动安装某个扩展包时提示 file-error，很可能是本地缓存
的数据已经过时了，该包在服务器上对应的文件已经被删除。这时需要手工运行
一下 package-refresh-contents 更新数据。

  use-package 宏支持许多关键字。
  - :init :: 加载扩展之前执行的代码。:init 部分应该尽可能简单，把配置
             放在 :config 部分
  - :config :: 加载扩展之后的执行的代码
  - :preface ::
  - :magic :: 设置 magic-mode-alist
  - :magic-fallback :: 设置 magic-fallback-mode-alist
  - :mode :: 设置 auto-mode-alist
  - :interpreter :: 设置 interpreter-mode-alist
  - :commands :: 命令成为 autoload
  - :bind :: 配置键绑定，对应的命令自动成为 autoload。可以结合 :map 设
             置 keymap
  - :bind* ::
  - :bind-keymap ::
  - :bind-keymap* ::
  - :defer :: 强制延后加载
  - :after :: 在指定 feature 加载后加载
  - :demand :: 强制立即加载
  - :if EXP :: 条件加载，比如某些配置仅适于 window-system
  - :disabled :: 禁用扩展包
  - :defines :: 用于抑制 byte-compile 时的警告
  - :functions :: 用于抑制 byte-compile 时的警告
  - :load-path :: 把指定目录加到 load-path
  - :diminish :: 配合 diminish
  - :delight :: 配合 delight
  - :ensure :: t 表示按需安装，也可以指定依赖的包
  - :pin :: 绑定到特定的 ELPA

  下面是一个例子。

#+BEGIN_SRC emacs-lisp-example
  (use-package color-moccur
    :commands (isearch-moccur isearch-all)
    :bind (("M-s O" . moccur)
           :map isearch-mode-map
           ("M-o" . isearch-moccur)
           ("M-O" . isearch-moccur-all))
    :init
    (setq isearch-lazy-highlight t)
    :config
    (use-package moccur-edit))

  (use-package helm
    :bind (("M-x" . helm-M-x)
           ("M-<f5>" . helm-find-files)
           ([f10] . helm-buffers-list)
           ([S-f10] . helm-recentf)))

  (use-package exec-path-from-shell
    :if (memq window-system '(mac ns))
    :ensure t
    :config
    (exec-path-from-shell-initialize))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (bw/install-package-on-demand 'use-package)
  (setq use-package-always-ensure t)
#+END_SRC
