* 显示
** 字体

#+BEGIN_SRC emacs-lisp
  (defun bw/set-mono-font ()
    (interactive)
    (progn
      (set-frame-font "-outline-Consolas-normal-r-normal-normal-18-*-*-*-c-*-iso10646-1")
      (dolist (charset '(kana han symbol cjk-misc bopomofo))
        (set-fontset-font (frame-parameter nil 'font)
                          charset (font-spec :family "Microsoft Yahei" :size 20)))))

  (bw/set-mono-font)
#+END_SRC

** 主题

  [[https://github.com/oneKelvinSmith/monokai-emacs][monokai-theme]] 源自 TextMate 的 Monokai Theme，是一个比较舒服的暗色主
题。

#+BEGIN_SRC emacs-lisp
  (use-package monokai-theme
               :ensure t
               :config
               (load-theme 'monokai t))
#+END_SRC

** Frame 标题

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format '("Emacs BW"))
#+END_SRC

** 最大化

#+BEGIN_SRC emacs-lisp
  (when bw/windows-p
    (toggle-frame-maximized))
#+END_SRC

* 交互
** Evil
*** Evil Mode

  Evil 的 Insert State 不能使用 Emacs 键绑定，使用时不方便，可以改为
Emacs State 的键绑定。下面的链接介绍了如果在 Evil 中实现这样的设置：
[[https://stackoverflow.com/questions/25542097/emacs-evil-mode-how-to-change-insert-state-to-emacs-state-automatically][Emacs evil-mode how to change insert-state to emacs-state automatically]]。

#+BEGIN_SRC emacs-lisp
  (use-package evil-leader
               :ensure t
               :config
               (evil-leader/set-leader "<SPC>")
               (evil-leader/set-key "ff" 'helm-find-files))

  (use-package evil
               :ensure t
               :config
               (global-evil-leader-mode)
               (evil-mode 1)
               ;; evil-insert-state 使用 evil-emacs-state 的键绑定，但可
               ;; 以用 ESC 退出到 evil-normal-state
               (setq evil-insert-state-map (make-sparse-keymap))
               (define-key evil-insert-state-map (kbd "<escape>") 'evil-normal-state))
#+END_SRC

** Helm

  [[https://github.com/emacs-helm/helm][Helm]]

#+BEGIN_SRC emacs-lisp
  (use-package helm
               :ensure t
               :bind (("M-x" . helm-M-x)
                      ("M-y" . helm-show-kill-ring))
               :config
               ;; 设置 helm-mini 包括的内容
               (setq helm-mini-default-sources '(helm-source-buffers-list
                                                 helm-source-recentf
                                                 helm-source-file-cache
                                                 helm-source-buffer-not-found))
               )
#+END_SRC

** which-key

  [[https://github.com/justbur/emacs-which-key][which-key]] 可以显示连续键中后续可选的键，非常酷炫。

#+BEGIN_SRC emacs-lisp
  (use-package which-key
               :ensure t
               :init
               (setq which-key-idle-delay 0.4)
               :config
               (which-key-mode))
#+END_SRC

** File Name Cache

  File Name Cache 是一个方便的快速打开常用文件的扩展。缺省情况下，在使
用 C-x C-f 的时候，键入 C-TAB 就会显示 File Name Cache 列表。不过，在
终端中使用 Emacs 的时候不能键入 C-TAB，下面的设置自定义了函数
file-cache-ido-find-file，通过和 ido 相似的界面打开常用文件。

#+BEGIN_SRC emacs-lisp
  (use-package filecache
               :commands file-cache-ido-find-file
               :init
               (evil-leader/set-key "fF" 'file-cache-ido-find-file)
               :config
               (file-cache-add-file-list (list "~/.emacs.d/init.el"))
               (file-cache-add-directory "~/.emacs.d/core" "config-.*.org")
               
               (defun file-cache-ido-find-file (file)
                 "Using ido, interactively open file from file cache'.
                  First select a file, matched using
                  ido-switch-buffer against the contents in
                  `file-cache-alist'. If the file exist in more
                  than one directory, select directory. Lastly the
                  file is opened."
                 (interactive
                  (list (file-cache-ido-read "File: "
                                             (mapcar
                                              (lambda (x)
                                                (car x))
                                              file-cache-alist))))
                 (let* ((record (assoc file file-cache-alist)))
                   (find-file
                    (expand-file-name
                     file
                     (if (= (length record) 2)
                         (car (cdr record))
                       (file-cache-ido-read
                        (format "Find %s in dir: " file) (cdr record)))))))

               (defun file-cache-ido-read (prompt choices)
                 (let ((ido-make-buffer-list-hook
                        (lambda ()
                          (setq ido-temp-list choices))))
                   (ido-read-buffer prompt))))
#+END_SRC
