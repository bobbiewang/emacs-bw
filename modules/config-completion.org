#+TITLE:     Completion

* Helm
** Helm

  [[https://github.com/emacs-helm/helm][Helm]] 是一个增量补全和过滤选择项的框架，输入框支持正则表达式和以空格
分隔的多重条件。

  M-x helm-mode 全局激活 Helm 补全，在 Emacs 中所有使用
completing-read（如 describe-function）或 read-file-name 的地方都会自
动使用 Helm 接口。

  在运行 Helm 时，用户能进行一些额外的操作，下面是几个常见的。可以执行
C-h m 查看 Helm 自带的帮助。
  - helm-select-action (Tab) :: 显示动作菜单
  - helm-execute-persistent-action (C-z) :: 选择当前项，不退出 minibuffer
  - helm-maybe-exit-minibuffer (RET)  :: 选择当前项，退出 minibuffer

  在 helm-mini、helm-find-files 中可以按 C-s 进入搜索模式。

  参考资料
  - [[https://tuhdo.github.io/helm-intro.html][A Package in a league of its own]]

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :if (eq bw/completion-framework 'helm)
    :ensure t
    :bind (("M-x"   . helm-M-x)
           ("M-y"   . helm-show-kill-ring)
           ("C-x b" . helm-mini))
    :config
    ;; 交换 TAB 和 C-Z
    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-z")  'helm-select-action)
    ;; Space 键绑定
    (bw/set-space-key-and-name
     "bi"  'helm-imenu      "imenu"
     "ff"  'helm-find-files nil
     "fF"  'helm-mini       nil
     "ha"  'helm-apropos    "apropos"
     "sf"  'helm-find       "find")
    ;; 设置 helm-mini 包括的内容
    (setq bw/helm-source-file-cache
          '((name . "File cache")
            (candidates . bw/file-cache-list)
            (action . (lambda (candidate)
                        (find-file candidate)))))
    (setq helm-mini-default-sources '(helm-source-buffers-list
                                      helm-source-recentf
                                      bw/helm-source-file-cache
                                      helm-source-buffer-not-found))
    (helm-mode 1))
#+END_SRC

** helm-descbinds

  [[https://github.com/emacs-helm/helm-descbinds][helm-descbinds]] 为 Emacs 的 describe-bindings 提供了 Helm 接口。

#+BEGIN_SRC emacs-lisp
  (use-package helm-descbinds
    :if (eq bw/completion-framework 'helm)
    :ensure t
    :init
    (helm-descbinds-mode))
#+END_SRC

* Ivy
** Ivy
  [[https://github.com/abo-abo/swiper][Ivy]] 是一个增量补全和过滤选择项的框架，比 Helm 轻量级，其实现分为三个
包：ivy、swiper、counsel。安装 counsel 会自动安装前两个依赖的包。

  M-x ivy-mode 全局激活 Ivy 补全，在 Emacs 中所有使用
completing-read-function 的地方会自动调用 Ivy 接口。

  参考资料
  - [[https://writequit.org/denver-emacs/presentations/2017-04-11-ivy.html][Ivy, Counsel and Swiper]]

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :if (eq bw/completion-framework 'ivy)
    :ensure t
    :bind (("M-x"     . counsel-M-x)
           ("C-x b"   . ivy-switch-buffer)
           ("C-x C-f" . counsel-find-file)
           ("M-`"     . counsel-imenu)
           ("M-y"     . counsel-yank-pop))
    :init
    ;; 把最近打开的文件和书签加到 ivy-switch-buffer 中
    (setq ivy-use-virtual-buffers t)
    (setq enable-recursive-minibuffers t)
    ;; 在 Ivy 补全界面中同时显示当前项序号和项目总数
    (setq ivy-count-format "%d/%d> ")
    (bw/set-space-key-and-name
     "bs" 'counsel-grep-or-swiper    "find in buffer"
     "bm" 'counsel-imenu             "imenu"
     "fa" 'counsel-apropos           "apropos"
     "ff" 'counsel-find-file         "open file"
     "fF" 'ivy-switch-buffer         "switch buffer"
     "hb" 'counsel-descbinds         "binding"
     "hf" 'counsel-describe-function "function"
     "hF" 'counsel-describe-face     "face"
     "hv" 'counsel-describe-variable "variable"
     "sa" 'counsel-ag                "ag"))
#+END_SRC

** ivy-hydra

  [[https://github.com/abo-abo/swiper][ivy-hydra]] 为 Ivy 提供了 hydra-ivy/body 命令，在 Ivy 界面按 C-o，可以
调出 [[https://github.com/abo-abo/hydra][Hydra]] 的功能介绍界面。

#+BEGIN_SRC emacs-lisp
  (use-package ivy-hydra
    :if (eq bw/completion-framework 'ivy)
    :ensure t)
#+END_SRC

** smex

  Ivy 的 counsel-M-x 缺省命令列表的排序是固定的，安装了 smex 后会使用
smex 的数据，最近用的命令列在前面。

#+BEGIN_SRC emacs-lisp
  (use-package smex
    :if (eq bw/completion-framework 'ivy)
    :ensure t
    :init
    (setq smex-save-file (locate-user-emacs-file ".smex-items")))
#+END_SRC

* YASnippet

  [[https://github.com/joaotavora/yasnippet][YASnippet]] 是 Emacs 中一个流行的模版系统。

  安装 YASnippet 后，有两种方式激活。
  - M-x yas-global-mode 全局激活
  - 通过 yas-reload-all 加载 Snippets，在 hook 中通过 yas-minor-mode
    激活

  YASnippet 的 Snippet 目录通过 yas-snippet-dirs 设置，其子目录以
Major Mode 的名字组织。

  在使用 YASnippet 的过程中，如果需要新加一个 Snippet，可以运行
yas-new-snippet 创建新的 Snippet；如果需要修改现成的 Snippet，可以 M-x
yas-visit-snippet-file 打开相应的 Snippet 文件修改。

  参考资料：
  - [[http://joaotavora.github.io/yasnippet/][Yet another snippet extension]] 官方文档

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :commands (yas-global-mode yas-minor-mode)
    :init
    (add-hook 'org-mode-hook #'yas-minor-mode)
    (add-hook 'c-mode-common-hook #'yas-minor-mode)
    :config
    (yas-reload-all))
#+END_SRC

* Company

  [[http://company-mode.github.io/][Company]] 是一个自动补全框架。

  | M-x company-mode     | 激活 Company 模式      |
  | M-x company-complete | 补全命令，可以手动激发 |
  | M-n、M-p             | 在候选内容中选择       |
  | C-s、C-r、C-o        | 在候选内容中搜索       |

  如果使用 company-clang 的话，需要通过 .dir-locals 文件让 Clang 知道
编译参数，尤其是 include 目录的路径。下面是一个例子。

#+BEGIN_SRC emacs-lisp-example
  ((nil . ((company-clang-arguments . ("-I/path/to/include1/"
                                       "-I/path/to/include2/"
                                       "-DDEBUG")))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :delight
    :config
    ;; 全局激活 Company Mode
    (add-hook 'after-init-hook 'global-company-mode)
    ;; 激发补全前等待时间，缺省是 0.5，修改成 0.1 会快一点
    (setq company-idle-delay 0.1))
#+END_SRC
